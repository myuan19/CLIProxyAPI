# 1 问题发现：缺少转换后的真实请求

目前详细日志 是用户请求 响应1 响应2 响应 3 最终响应，原因是有重试。中间请求省略掉原因是相同。但我突然意识到完整流程是用户请求 [真实请求（转换后的），响应1，响应2，...] 最终响应。中间[] 是重试部分，也就是漏了转换后的真实请求，对吗。

---

现在我完全理解了。你的分析是**正确的**，确实漏了转换后的真实请求。让我把完整情况解释清楚。

## 现状分析

### 后端数据结构 (`DetailedRequestRecord`)

后端**已经有**每次 attempt 的请求数据：

```66:79:/root/workspace/CLIProxyAPI/internal/logging/detailed_request_logger.go
type DetailedAttempt struct {
	Index           int                 `json:"index"`
	Timestamp       time.Time           `json:"timestamp,omitempty"`
	UpstreamURL     string              `json:"upstream_url,omitempty"`
	Method          string              `json:"method,omitempty"`
	Auth            string              `json:"auth,omitempty"`
	RequestHeaders  map[string][]string `json:"request_headers,omitempty"`
	RequestBody     string              `json:"request_body,omitempty"`
	StatusCode      int                 `json:"status_code,omitempty"`
	ResponseHeaders map[string][]string `json:"response_headers,omitempty"`
	ResponseBody    string              `json:"response_body,omitempty"`
	Error           string              `json:"error,omitempty"`
	DurationMs      int64               `json:"duration_ms,omitempty"`
}
```

每次 executor 调用 `recordAPIRequest` 时，传入的 `Body` 就是**转换后的真实请求**（如 Gemini 格式而非 OpenAI 格式）：

```385:395:/root/workspace/CLIProxyAPI/internal/runtime/executor/gemini_executor.go
	recordAPIRequest(ctx, e.cfg, upstreamRequestLog{
		URL:       url,
		Method:    http.MethodPost,
		Headers:   httpReq.Header.Clone(),
		Body:      translatedReq,    // ← 这是转换后的 Gemini 格式请求
		Provider:  e.Identifier(),
		// ...
	})
```

### 前端只展示了响应，跳过了请求

前端 `RetryItemBlock`（line 151-152）的注释写得很清楚：

```151:152:/root/workspace/Cli-Proxy-API-Management-Center/src/components/logs/DetailedRequestsTab.tsx
/** 重试部分单项：仅展示响应（请求体与首次相同，不重复展示）；折叠时标题显示状态码与尝试序号 */
```

所以前端显示的流程是：

```
用户请求(OpenAI格式) → [响应1, 响应2, ...] → 最终响应
```

### 还有一个后端 bug

部分 executor 的**流式路径**中，请求体只在 `RequestLog` 开启时才记录，`DetailedRequestLog` 开启时不记录：

```1341:1349:/root/workspace/CLIProxyAPI/internal/runtime/executor/antigravity_executor.go
	var payloadLog []byte
	if e.cfg != nil && e.cfg.RequestLog {      // ← 只看 RequestLog，不看 DetailedRequestLog
		payloadLog = []byte(payloadStr)
	}
	recordAPIRequest(ctx, e.cfg, upstreamRequestLog{
		// ...
		Body:      payloadLog,                  // ← 如果 RequestLog=false，这里是 nil → "<empty>"
		// ...
	})
```

这意味着即使后端字段有 `request_body`，在某些流式路径下实际存的是 `<empty>`。

---

## 总结

你说得对，完整流程应该是：

```
用户请求(OpenAI) → [真实请求(转换后格式) + 响应1, 真实请求 + 响应2, ...] → 最终响应(转回OpenAI)
```

目前有两个问题：

1. **前端缺失**：`RetryItemBlock` 不展示 `attempt.request_body`、`attempt.upstream_url`、`attempt.request_headers`，即使后端有这些数据
2. **后端部分缺失**：某些 executor 的流式路径中，`DetailedRequestLog` 开启时不记录请求体（条件判断只看 `RequestLog`）

如果要修复，需要：

- 后端：统一所有 executor 的 `recordAPIRequest` 调用，让 `DetailedRequestLog` 也能拿到请求体
- 前端：在重试部分里展示每次 attempt 的转换后请求（URL + headers + body）

---

# 2 UI 设计：内部处理过程展示结构

加上吧，默认显示用户请求和最终响应，开启显示重试部分（改个名字，你想想，含义是显示内部处理原理）后，加上中间那个块，点开后是实际请求+重试1（如果有）重试2..最终返回。都要像现在这样有header默认折叠。按理来说最终返回是内部返回的，然后最终响应是给用户的，我不知道一不一样你自己看。

---

我先回答你的问题，帮你理清设计：

### "最终返回"和"最终响应"是否一样？

**不一样**，它们是两个不同的东西：

- **最终返回**（内部）：最后一次 attempt 从上游拿到的原始响应，可能是 Gemini/Anthropic 等格式
- **最终响应**（给用户）：经过格式转换后（转回 OpenAI 格式），通过 proxy 返回给用户的响应，headers 也是 proxy 自己设置的

所以中间块里应该包含最后一次 attempt 的响应，和外层的"最终响应"并不重复。

### 整体结构设计

```
默认视图：
  ▶ 用户请求（headers 折叠 + body）
  ▶ 最终响应（headers 折叠 + body）

开启"显示内部处理"后：
  ▶ 用户请求（headers 折叠 + body）
  ▼ 内部处理过程 (N 次尝试)
      ▶ 实际请求（转换后的上游请求，URL + auth + headers 折叠 + body）
      ▶ 上游响应 #1 [403]        ← 如果有重试
      ▶ 上游响应 #2 [429]        ← 如果有重试
      ▶ 上游响应 #3 [200]        ← 最终拿到的上游原始响应
  ▶ 最终响应（headers 折叠 + body）
```

### 命名建议

"显示重试部分" → **"显示内部处理"** 或 **"显示处理详情"**

英文对应：`Show Retries` → **`Show Internal Processing`** 或 **`Show Processing Details`**

含义是：展示请求在系统内部的完整处理过程，包括格式转换后的真实请求、每次上游尝试、以及原始上游响应。

---

# 3 Auth 信息说明：从配置到请求头的转换流程

auth 行本身不会原样发送，它只是客户端本地的配置。

完整流程：

```
┌─────────────────────────────────────────────────────┐
│ 配置文件中的 auth 行                                   │
│ "provider=antigravity, auth_id=xxx.json, type=oauth" │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────┐
│ 1. 解析 auth_id → 找到本地凭证文件                     │
│    ~/.antigravity/credentials/xxx.json               │
│    读取 access_token                                  │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────┐
│ 2. 构造 HTTP 请求，将 token 放入 Header               │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────┐
│ 3. 发送请求到 API 服务器                               │
└─────────────────────────────────────────────────────┘
```

---

# 4 排查：Executor 内部重试 vs 统一路由 Failover

@CLIProxyAPI/logs/detailed-requests/detail-v1-chat-completions-2026-02-11T184514-0211666f.json 看一下为什么会重试那么多次，同一个配置。不是有问题就切换吗

---

数据很清楚了。整理一下这 17 次尝试的情况：

| 尝试      | Auth (凭证)                            | URL                                                  | 状态             |
| --------- | -------------------------------------- | ---------------------------------------------------- | ---------------- |
| #1 ~ #13  | **huonglocha5745@gmail.com**     | 交替 `googleapis.com` / `sandbox.googleapis.com` | 全部 503         |
| #14 ~ #16 | **guillaumedidier607@gmail.com** | 交替                                                 | 全部 503         |
| #17       | **gurafabrice@gmail.com**        | `googleapis.com`                                   | **200** ✓ |

错误全部是：`MODEL_CAPACITY_EXHAUSTED` — "No capacity available for model claude-opus-4-6-thinking"

---

## 问题原因

这**不是**统一路由的 failover 行为。你看到的 13 次重复用同一个凭证，是 **antigravity executor 内部的重试逻辑**。

antigravity executor 内部有两个 endpoint（`daily-cloudcode-pa.googleapis.com` 和 `daily-cloudcode-pa.sandbox.googleapis.com`），它在这两个 URL 之间反复交替重试。每次 503 后它认为"另一个 endpoint 可能有容量"，于是换 URL 再试——但凭证没变，所以对 Google 来说结果是一样的。

**流程实际是这样的**：

```
统一路由 target 1 (huonglocha5745)
  → antigravity executor 内部重试 13 次（在两个 URL 间交替）
  → 全部 503，返回失败
统一路由 target 2 (guillaumedidier607)  
  → antigravity executor 内部重试 3 次
  → 全部 503，返回失败
统一路由 target 3 (gurafabrice)
  → 第 1 次就成功 200 ✓
```

统一路由的"有问题就切换"是在**整个 target 失败后**才切换。但问题是 antigravity executor 内部在同一个 target 上重试了**太多次**（13 次），每次都是 503 容量耗尽，明显是徒劳的。

## 根本问题

antigravity executor 对 503 `MODEL_CAPACITY_EXHAUSTED` 的处理策略过于激进——它把这种错误当作"可能换个 endpoint 就好了"，所以反复重试。但实际上这种容量耗尽跟 endpoint 无关，跟 **凭证/账号的配额** 更相关，应该更快地放弃当前 target，让统一路由切换到下一个凭证。

---

*哦这是 antigravity 自带的逻辑啊*

---

对，这是 antigravity executor **自己内部**的重试逻辑，不是统一路由的 failover。

*antigravity executor 内部维护了两个 endpoint URL（`googleapis.com` 和 `sandbox.googleapis.com`），遇到失败会在它们之间来回切换重试。这个重试循环是在 executor 内部完成的，对统一路由来说，整个过程就是"一个 target 在尝试中"。*

只有当 executor 内部重试全部耗尽、最终返回失败后，统一路由引擎才会拿到这个失败结果，然后切换到下一个 target（不同凭证）。

所以你看到的 13 次同凭证重试，是 antigravity executor 在自己的两个 endpoint 间反复弹跳，统一路由并没有介入。统一路由实际只切换了 3 次（3 个不同的凭证/target）。

# 5 无响应场景处理与间距/retries 优化

如果没有响应会如何记录，看看代码有没有处理。

---

构建通过。总结所有改动：

---

### 1. 间距交换

新增两个 CSS class：

- `.attemptGroup` — 同组内的响应之间间距紧凑（`4px`）
- `.attemptGroupNew` — 切换到新节点/配置时，上方留大间距（`16px`）+ 虚线分隔

`retryItemBlock` 的内部间距也从 `10px` 缩小到 `4px`。

效果变成：

```
[上游请求 → POST https://...A]     ← 同组
    4px                              ← 紧凑
[上游响应 [503] 尝试 #1]            ← 同组
    4px                              ← 紧凑
[上游响应 [503] 尝试 #2]            ← 同组（URL/Auth 相同，不展示请求）
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─          ← 虚线 + 16px 间距
[上游请求 → POST https://...B]     ← 新组（切换了节点）
    4px
[上游响应 [200] 尝试 #3]
```

### 2. retries 含义修正

- **原来**：`retries = attempts.length - 1`（17 attempts → 16 retries），纯粹是总次数 -1
- **现在**：`retries = uniqueTargets - 1`，按 `auth` 字段去重统计不同节点数量。17 attempts 用了 3 个不同凭证 → `2 retries`
- hover 提示：鼠标放上去显示 `"重试了 2 个新节点"`

### 3. 关于"无响应"的处理

后端已经完整覆盖了：

- **正常 HTTP 响应**（有状态码+body）→ `recordAPIResponseMetadata` 记录 status + headers，`appendAPIResponseChunk` 记录 body
- **无 HTTP 响应**（连接失败、超时等）→ `recordAPIResponseError` 记录 error 文本，`status_code` 保持 0
- **中间件解析**时 `mergeAttemptResponses` 处理了 `Error:` 行，会填充 `target.Error`
- **前端** `AttemptResponseBlock` 也处理了：当 `status_code` 为空且有 `error` 时，标题显示红色 "Error"，展开后显示错误详情

所以无响应的情况是正常处理的，attempt 记录中会有 `error` 字段，`status_code` 为 0，前端会正确展示。

---

如果是error前端就别显示 状态码了，目前是这样吗

---

是的，目前已经正确处理了。看当前代码逻辑：

**第 226 行**：`attempt.status_code != null` — 只有有状态码时才显示 badge
**第 234 行**：`attempt.error && !attempt.status_code` — 只有有 error 且**没有**状态码时才显示红色 "Error"

后端的 Go 结构体用了 `omitempty`：

```go
StatusCode int `json:"status_code,omitempty"`
```

所以当没有 HTTP 响应（连接失败/超时）时，`status_code` 在 JSON 中不会出现（值为 0 被 omitempty 跳过），前端拿到的是 `undefined`。

三种场景的表现：

| 场景             | status_code | error | 标题显示                                          |
| ---------------- | ----------- | ----- | ------------------------------------------------- |
| 正常 503 响应    | 503         | 无    | `上游响应 [503] [尝试 #1]`                      |
| 503 + error      | 503         | 有    | `上游响应 [503] [尝试 #1]`（展开后有 error 块） |
| 无响应（超时等） | undefined   | 有    | `上游响应 [尝试 #1] Error`（无状态码 badge）    |

已经是你期望的行为了，error 时不显示状态码。
