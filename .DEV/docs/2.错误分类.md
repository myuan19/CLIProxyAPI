智能路由，如何判断请求某个节点不通，是因为这个节点问题，还是其他问题。即是这个节点不通其他可能通，还是这个不通其他也一定不通。

---

这是一个非常好的问题。我仔细分析了当前的智能路由实现，下面给你一个完整的分析。

## 当前状况：所有错误被"一视同仁"

当前 `ExecuteWithFailover` 的逻辑（`engine.go:346-448`）存在一个明显缺陷：**所有错误都被当作节点级故障处理**，无差别地触发 cooldown 和重试。

```347:448:CLIProxyAPI/internal/api/modules/unified-routing/engine.go
func (e *DefaultRoutingEngine) ExecuteWithFailover(
	ctx context.Context,
	decision *RoutingDecision,
	executeFunc func(ctx context.Context, auth *coreauth.Auth, model string) error,
) error {
// ... 无论什么错误，都走同样的路径 ...
```

这意味着：
- 用户发了一个**格式错误的请求**（400 Bad Request），系统会在所有节点逐个尝试，全部失败后把所有节点都放进冷却期 — 这完全是浪费
- 某个节点的 **API Key 过期**（401），重试到下一个节点是合理的
- **速率限制**（429），可能只是该节点的配额用完了，其他节点可能没问题

---

## 错误分类方案

核心思路是按 HTTP 状态码和错误类型，将错误分为三类：

### 1. 节点级故障（应该重试）— "这个不通，其他可能通"

| 错误类型 | HTTP 状态码 | 说明 |
|---------|-----------|------|
| 认证失败 | 401 | 该节点的 Key/Token 无效，其他节点有自己的凭据 |
| 付费/配额问题 | 402, 403 | 该节点账户欠费或权限不足 |
| 速率限制 | 429 | 该节点配额用完，其他节点可能还有 |
| 服务端错误 | 500, 502, 503 | 该节点服务暂时不可用 |
| 网络超时 | timeout | 该节点连接超时，可能网络抖动 |
| 连接错误 | connection refused/reset | 该节点不可达 |

### 2. 请求级故障（不应重试）— "这个不通，其他也一定不通"

| 错误类型 | HTTP 状态码 | 说明 |
|---------|-----------|------|
| 请求格式错误 | 400 | 请求体本身有问题，换节点也一样报错 |
| 内容审核拒绝 | 400 (safety) | 请求内容被安全过滤 |
| 上下文太长 | 400 (token limit) | 请求 tokens 超限，所有节点限制相同 |
| 模型不存在 | 404 | 请求的模型不存在（如果所有节点配的是同一模型）|
| 请求实体过大 | 413 | payload 本身太大 |

### 3. 灰色地带（需要特殊判断）

| 错误类型 | 说明 |
|---------|------|
| 404 模型不存在 | 如果不同节点配了不同模型，可能该节点没有但其他有 |
| 400 但包含 "overloaded" | 某些 provider 用 400 返回过载信息 |
| 网络层错误 | 如果所有节点共用同一个 proxy/出口，则全部不通 |

---

## 具体实现思路

系统已经有 `StatusError` 接口可以获取 HTTP 状态码：

```59:65:CLIProxyAPI/sdk/cliproxy/executor/types.go
// StatusError represents an error that carries an HTTP-like status code.
// Provider executors should implement this when possible to enable
// better auth state updates on failures (e.g., 401/402/429).
type StatusError interface {
	error
	StatusCode() int
}
```

可以在 `ExecuteWithFailover` 的错误处理环节加入分类逻辑：

```go
// ErrorClass 表示错误的可重试分类
type ErrorClass int

const (
    // ErrorClassRetryable - 节点级问题，应重试其他节点
    ErrorClassRetryable ErrorClass = iota
    // ErrorClassNonRetryable - 请求级问题，换节点也没用
    ErrorClassNonRetryable
    // ErrorClassUnknown - 无法判断，保守策略：重试
    ErrorClassUnknown
)

func ClassifyError(err error) ErrorClass {
    // 1. 检查是否有 HTTP 状态码
    var statusErr cliproxyexecutor.StatusError
    if errors.As(err, &statusErr) {
        code := statusErr.StatusCode()
        switch {
        // 请求本身有问题 - 不重试
        case code == 400:
            // 进一步检查错误信息区分 "overloaded" vs "invalid request"
            msg := strings.ToLower(err.Error())
            if strings.Contains(msg, "overloaded") || 
               strings.Contains(msg, "capacity") {
                return ErrorClassRetryable  // 过载是节点问题
            }
            return ErrorClassNonRetryable
        case code == 413:
            return ErrorClassNonRetryable
        case code == 422:
            return ErrorClassNonRetryable
            
        // 认证/配额问题 - 重试（不同节点不同凭据）
        case code == 401, code == 402, code == 403:
            return ErrorClassRetryable
        case code == 429:
            return ErrorClassRetryable
            
        // 服务端问题 - 重试
        case code >= 500:
            return ErrorClassRetryable
            
        // 404 - 看情况
        case code == 404:
            // 如果不同节点用不同模型，404 可以重试
            return ErrorClassRetryable
        }
    }
    
    // 2. 检查网络层错误
    var netErr *net.OpError
    if errors.As(err, &netErr) {
        return ErrorClassRetryable  // 网络错误是节点级别的
    }
    
    // 3. 超时 - 通常是节点级问题
    if errors.Is(err, context.DeadlineExceeded) {
        return ErrorClassRetryable
    }
    
    // 4. 客户端主动取消 - 不重试
    if errors.Is(err, context.Canceled) {
        return ErrorClassNonRetryable
    }
    
    // 5. 默认：保守重试
    return ErrorClassUnknown
}
```

然后在 `ExecuteWithFailover` 中使用：

```go
// 在 engine.go 的失败处理中
if err != nil {
    errClass := ClassifyError(err)
    
    switch errClass {
    case ErrorClassNonRetryable:
        // 请求本身有问题，直接返回，不冷却任何节点
        trace := traceBuilder.Build(time.Since(startTime).Milliseconds())
        e.metrics.RecordRequest(trace)
        return err  // 立即返回，不浪费其他节点
        
    case ErrorClassRetryable:
        // 节点问题，冷却该节点，继续尝试下一个
        e.stateMgr.RecordFailure(ctx, target.ID, err.Error())
        e.stateMgr.StartCooldown(ctx, target.ID, cooldownDuration)
        continue
        
    case ErrorClassUnknown:
        // 不确定，重试但不冷却（避免误杀好节点）
        // 或者用更短的冷却期
        e.stateMgr.RecordFailure(ctx, target.ID, err.Error())
        e.stateMgr.StartCooldown(ctx, target.ID, cooldownDuration/2)
        continue
    }
}
```

---

## 更进一步：关联分析

还有一种高级策略：**如果连续多个节点都返回同样的错误，推断为请求级问题**：

```go
// 在 failover 循环中追踪
var lastErrors []error

for {
    // ... 尝试节点 ...
    if err != nil {
        lastErrors = append(lastErrors, err)
        
        // 如果连续 2+ 个节点返回相同类型的错误
        if len(lastErrors) >= 2 && isSameErrorPattern(lastErrors) {
            // 很可能是请求本身的问题
            return err  // 提前退出
        }
    }
}
```

这样即使最初无法确定错误类型（ErrorClassUnknown），在观察到多个节点都报相同错误后，也能快速止损。

---

## 总结

| 判断维度 | 节点问题（重试） | 请求问题（不重试） |
|---------|--------------|---------------|
| HTTP 状态码 | 401/402/403/429/5xx | 400/413/422 |
| 网络错误 | 连接超时/拒绝/重置 | — |
| 错误模式 | 仅单个节点失败 | 多个节点返回相同错误 |
| 错误内容 | "rate limit" / "quota" / "unavailable" | "invalid" / "malformed" / "too large" |