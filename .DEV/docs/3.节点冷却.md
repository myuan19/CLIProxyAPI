健康检查不是针对进入冷却的30s一次嘛，这样，在有外界请求正在处理的时间范围里，30s到期如果发现还不通就进入下一个30s。但如果30s到期的时候已经位于正在处理的时间范围之外，则检查通过恢复健康，检查未通过进入不带倒计时的冷却。直到再进入正在处理的时间范围里，进行一次健康检查先，决定状态。可以维护一个变量，表示当前是否正在处理（只看当前这个路由），如果是且不通进入下一个30s，如果通了恢复，如果不是且没通就进入不计时冷却，如果通了就恢复，如果处理状态为true让不计时冷却状态的检查一次，如此循环。状态前端如果倒计时还像现在这样倒计时，如果是不计时冷却显示冷却二字，颜色和倒计时一样。绿色则正常，和当前相同。

---

你这个设计引入了「是否正在处理请求」这个维度来决定冷却行为，我整理一下你的状态机，然后谈谈看法。

---

### 你的设计（状态机整理）

**新增变量**：`isProcessing`（当前路由是否有活跃请求）

**冷却状态分两种**：
| 状态 | 触发条件 | 行为 |
|------|----------|------|
| **倒计时冷却** | `isProcessing=true` 且健康检查未通过 | 30s 后再检查，循环 |
| **不计时冷却** | `isProcessing=false` 且健康检查未通过 | 挂起，不再定时检查 |

**转换规则**：
1. 倒计时冷却中，30s 到了检查通过 → **恢复健康**
2. 倒计时冷却中，30s 到了检查不通过，但此时 `isProcessing=false` → **转为不计时冷却**
3. 倒计时冷却中，30s 到了检查不通过，且 `isProcessing=true` → **继续下一个 30s**
4. 不计时冷却中，`isProcessing` 变为 `true` → **立即做一次健康检查**
   - 通过 → 恢复健康
   - 不通过 → 进入 30s 倒计时冷却

**前端展示**：
- 倒计时冷却 → 倒计时数字（和现在一样）
- 不计时冷却 → 显示「冷却」文字，颜色同倒计时
- 健康 → 绿色，同当前

---

### 我的看法

**整体思路是合理的**，核心逻辑是「没流量时别白费检查，有流量时才积极检查」。不过有几个点值得想清楚：

#### 1. `isProcessing` 的粒度和定义

- 是「当前有至少一个请求正在被这条路由处理」还是「最近 N 秒内有过请求」？
- 如果是前者，一个请求可能就几百毫秒，30s 检查周期内 `isProcessing` 绝大部分时间是 `false`，基本上大多数 30s 到期时都会进入不计时冷却。
- **建议**：用「最近 N 秒内该路由有过请求」（比如 60s 或 120s）作为判断依据，或者用「该路由当前有排队/活跃请求」。这样更稳定，不会因为请求太短暂而频繁切换。

#### 2. 不计时冷却 → 有请求来时的「立即检查」

- 新请求进来，发现目标处于不计时冷却，触发立即健康检查。但健康检查可能需要几百毫秒到几秒。**这个请求要等检查结果吗？**
- 如果等 → 增加首个请求的延迟
- 如果不等 → 这个请求只能路由到其他健康目标，检查结果只影响后续请求
- **建议**：不等，当前请求走其他健康目标，异步触发检查。检查通过后下一个请求就能用这个目标了。

#### 3. 简化可能：只保留两个状态

其实你的设计可以更简洁地表述为：

- **冷却中**：统一一个冷却状态
- **有活跃流量时**：每 30s 做一次健康检查（和现在一样）
- **无活跃流量时**：停止定时检查，节省资源
- **流量恢复时**：触发一次即时检查

这样前端只需要：
- 有流量 + 冷却中 → 显示倒计时（30s 周期）
- 无流量 + 冷却中 → 显示「冷却」
- 健康 → 绿色

本质上不需要两种冷却「状态」，只需要一个冷却状态 + 检查策略根据 `isProcessing` 动态调整。实现上更简单，状态管理也少一层。

#### 4. 边界情况

- **所有目标都冷却了**：这时 `isProcessing` 肯定是 `false`（没地方路由），所有目标都进不计时冷却，永远不会有请求触发检查。需要一个兜底：即使没流量，也至少保持一个最低频率的检查（比如 5 分钟一次），避免全部永久冷却。

---

### 总结

| 方面 | 评价 |
|------|------|
| 核心思路 | 合理，按需检查，节省资源 |
| `isProcessing` 定义 | 建议用「近 N 秒有请求」而非瞬时值 |
| 即时检查时机 | 建议异步，不阻塞当前请求 |
| 实现复杂度 | 可以简化为「一种冷却 + 检查策略动态调整」 |
| 兜底机制 | 需要防止全部目标永久冷却的情况 |

---

可以，isprocessing表示最近20s路由有过请求。注意这个路由是指的别名入口，内部会有Layer和每个layer的节点。2.不用等待结果，先异步开启处理请求然后对不计时冷却的节点进行健康检查。因为有几个在冷却中，还有剩下空余节点可以走。

---

好的，设计进一步清晰了，我梳理一下最终方案。

---

### 最终设计

**`isProcessing` 定义**：该路由（别名入口）在最近 **20s** 内有过请求。

**层级关系**：
```
路由（别名入口）→ Layer → 节点（target）
```
- `isProcessing` 在**路由级别**维护
- 冷却状态在**节点级别**维护

---

### 状态机（节点级别）

```
           请求失败
  健康 ──────────────► 倒计时冷却 (30s)
   ▲                      │
   │                  30s 到期
   │                      │
   │          ┌───────────┴───────────┐
   │    isProcessing=true        isProcessing=false
   │          │                       │
   │      健康检查                  健康检查
   │       ╱    ╲                  ╱    ╲
   │     通过   不通过           通过   不通过
   │      │       │              │       │
   └──────┘   继续下一个30s      │   不计时冷却
   └─────────────────────────────┘       │
                                         │
                              isProcessing 变 true
                                         │
                                     异步健康检查
                                      ╱    ╲
                                    通过   不通过
                                     │       │
                                   恢复   进入30s倒计时冷却
```

---

### 请求处理流程

```
请求进入（别名入口）
  │
  ├─ 更新 isProcessing 时间戳（记录 now）
  │
  ├─ 选择健康/可用节点处理请求（正常路由逻辑）
  │
  └─ 异步：检查是否有「不计时冷却」的节点
       └─ 有 → 对它们触发一次即时健康检查
            ├─ 通过 → 恢复健康（后续请求可用）
            └─ 不通过 → 进入 30s 倒计时冷却
```

请求**不等待**健康检查结果，直接走剩余可用节点。

---

### 前端展示

| 节点状态 | 显示 | 颜色 |
|----------|------|------|
| 健康 | 正常（同现在） | 绿色 |
| 倒计时冷却 | 倒计时数字（同现在） | 同现在的冷却色 |
| 不计时冷却 | 「冷却」文字 | 同倒计时颜色 |

---

### 还有一个边界需要确认

**同一 Layer 内所有节点都冷却了的情况**：

- 如果全部进入「不计时冷却」，请求进来时没有可用节点。
- 此时请求触发的异步健康检查还没出结果，**当前这个请求怎么处理？**
  - **选项 A**：对这个请求同步等一次健康检查（因为没有其他节点可走了）
  - **选项 B**：直接返回错误（如 503），让客户端重试
  - **选项 C**：挑一个冷却中的节点硬路由过去碰运气

你倾向哪种？这会影响实现逻辑。

---

目前是先异步正常请求，并发起对冷却节点的健康检查。按照正常逻辑，健康检查还没返回，此时异步正常请求拿不到能用的节点对吧，然后会走503？那就这样吧，不需要特殊处理，默认即可。

---

对，就是这样。当所有节点都在冷却中时：

1. 请求进来 → 更新 `isProcessing` 时间戳 → 尝试选节点
2. 没有可用节点 → 正常走现有的 503 逻辑
3. 同时异步触发对「不计时冷却」节点的健康检查
4. 如果检查通过 → 节点恢复，**下一个请求**就能用了

完全不需要特殊处理，现有的 503 兜底自然覆盖了这个边界。而且因为请求本身也会更新 `isProcessing`，所以即使返回了 503，也会把不计时冷却的节点「唤醒」去做检查，后续请求就有机会恢复。

---

整个方案已经闭环了，要点回顾：

- **删掉** `DefaultCooldownSeconds`、`CooldownSeconds`、`CooldownEndsAt` 这些冷却时间参数
- **新增** 路由级别的 `isProcessing`（最近 20s 有请求即为 true）
- **冷却恢复** 完全由健康检查决定，不再依赖时间到期
- **两种冷却态**：倒计时冷却（30s 周期检查）和不计时冷却（等流量唤醒）
- **全冷却时** 503 + 异步唤醒，不做特殊处理
- **前端**：倒计时 / 「冷却」文字 / 绿色健康，三种展示


---

当前的设计是全局共享一个 ticker 定时轮询，而不是每个 target 独立计时。让我重新设计为 per-target 独立定时器。

构建通过。以下是本次重构的完整总结：
核心设计变更：全局 ticker 轮询 → per-target 独立定时器
旧设计（有问题）：一个全局 ticker 每 N 秒扫描所有 target，CooldownEndsAt 过期后要等到下一次 tick 才被检查，存在不可控延迟。
新设计（per-target timer）：每个 target 进入 timed cooling 时，通过 time.AfterFunc(delay, callback) 创建独立定时器，精确在 CooldownEndsAt 到期时触发该 target 的健康检查。

流程变为：
target 失败 → StartCooldownTimed（设 CooldownEndsAt=now+30s）→ ScheduleTargetCheck（创建 30s 定时器）→ 精确 30s 后触发 → 健康检查 → 如果不通过且路由活跃 → SetCooldownNextCheckIn + 再次 ScheduleTargetCheck → 下一个精确 30s…

---

健康检查单独为一个状态，叫检查中。不计时冷却中触发的健康检查也应该变成"检查中"。改造后，两条路径都会经历"检查中"：
per-target timer 触发（onTargetCheckDue）：cooling(倒计时到0) → checking → healthy 或 cooling(新30s)
请求触发（TriggerCheckUntimedCoolingTargets）：cooling(无期限) → checking → healthy 或 cooling(新30s)
前端用户看到的效果是：不管哪种冷却状态，一旦开始做健康检查，都会显示蓝色"检查中"，而不是一直卡在"冷却中"不动。这个体验是一致且符合直觉的。

---

冷却中 还是应该保留的，在不计时冷却的时候 @CLIProxyAPI/.DEV/docs/3.节点冷却.md:109-133 

---

已按文档恢复逻辑，修改总结如下：

## 修改说明

**逻辑（与 3.节点冷却.md 一致）：**

| 状态 | 条件 | 显示 |
|------|------|------|
| 倒计时冷却 | `status === 'cooling'` 且 `cooldown_remaining_seconds > 0` | `○ 28s` |
| **不计时冷却** | `status === 'cooling'` 且 **无** `cooldown_ends_at`（或为空） | **`○ 冷却中`** |
| 倒计时结束到检查前 | `status === 'cooling'` 且 `cooldown_ends_at` 有值但 `seconds === 0` | `●` 蓝点 |
| 检查中 | `status === 'checking'` | `●` 蓝点 |
| 健康 | 其他 | `●` 绿点 |

区分方式：后端在**不计时冷却**时不会设置 `CooldownEndsAt`（API 里 `cooldown_ends_at` 为 null/缺失），前端用「有/无 `cooldown_ends_at`」区分：

- **有** `cooldown_ends_at` 且 `seconds > 0` → 倒计时冷却 → 显示秒数  
- **有** `cooldown_ends_at` 且 `seconds === 0` → 倒计时刚结束的间隙 → 显示蓝点  
- **无** `cooldown_ends_at` → 不计时冷却 → 显示 **「冷却中」**

`formatCooldown` 已恢复为接收整个 `state`，并在不计时冷却时返回 `t('unified_routing.cooling')`（中文「冷却中」/ 英文 "Cooling"）。

